<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>IGD Control Point User&#39;s Manual: 문서/IGD_Client.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IGD Control Point User&#39;s Manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2f56116f5c2b72888cc5cda3c2a7e2c8.html">문서</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">IGD_Client.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;pthread.h&gt;</code><br />
<code>#include &quot;IGD_ControlPointStructs.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for IGD_Client.h:</div>
<div class="dyncontent">
<div class="center"><img src="_i_g_d___client_8h__incl.png" border="0" usemap="#_xEB_xAC_xB8_xEC_x84_x9C_2_i_g_d___client_8h" alt=""/></div>
<map name="_xEB_xAC_xB8_xEC_x84_x9C_2_i_g_d___client_8h" id="_xEB_xAC_xB8_xEC_x84_x9C_2_i_g_d___client_8h">
</map>
</div>
</div>
<p><a href="_i_g_d___client_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigd__handle__tag.html">igd_handle_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8499fc64cf0249d1a6a1276840b27f68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8499fc64cf0249d1a6a1276840b27f68"></a>
typedef struct <a class="el" href="structigd__handle__tag.html">igd_handle_tag</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_HANDLE</b></td></tr>
<tr class="separator:a8499fc64cf0249d1a6a1276840b27f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0471966a31e2c65693679fb32ffdb71a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0471966a31e2c65693679fb32ffdb71a"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_ResponseSink_AddPortMapping</b>) (struct UPnPService *sender, int ErrorCode, void *user)</td></tr>
<tr class="separator:a0471966a31e2c65693679fb32ffdb71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b0b3dca09aa4d2b3a1f2767d4c8e87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70b0b3dca09aa4d2b3a1f2767d4c8e87"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_ResponseSink_DeletePortMapping</b>) (struct UPnPService *sender, int ErrorCode, void *user)</td></tr>
<tr class="separator:a70b0b3dca09aa4d2b3a1f2767d4c8e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fd1abb830569ce75a7f0ab8cb66a67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72fd1abb830569ce75a7f0ab8cb66a67"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_ResponseSink_ForceTermination</b>) (struct UPnPService *sender, int ErrorCode, void *user)</td></tr>
<tr class="separator:a72fd1abb830569ce75a7f0ab8cb66a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d24a09d538750e302804568c0406fbf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d24a09d538750e302804568c0406fbf"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_ResponseSink_GetConnectionTypeInfo</b>) (struct UPnPService *sender, int ErrorCode, void *user, char *NewConnectionType, char *NewPossibleConnectionTypes)</td></tr>
<tr class="separator:a4d24a09d538750e302804568c0406fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8278d5e9d859fadbbe31ae7dfbc9f790"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8278d5e9d859fadbbe31ae7dfbc9f790"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_ResponseSink_GetExternalIPAddress</b>) (struct UPnPService *sender, int ErrorCode, void *user, char *NewExternalIPAddress)</td></tr>
<tr class="separator:a8278d5e9d859fadbbe31ae7dfbc9f790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6b58abff426b4460662774452ff1db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb6b58abff426b4460662774452ff1db"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_ResponseSink_GetGenericPortMappingEntry</b>) (struct UPnPService *sender, int ErrorCode, void *user, char *NewRemoteHost, unsigned short NewExternalPort, char *NewProtocol, unsigned short NewInternalPort, char *NewInternalClient, int NewEnabled, char *NewPortMappingDescription, unsigned int NewLeaseDuration)</td></tr>
<tr class="separator:afb6b58abff426b4460662774452ff1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9aaea4fe103262a2d9889ad54dcbc4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff9aaea4fe103262a2d9889ad54dcbc4"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_ResponseSink_GetNATRSIPStatus</b>) (struct UPnPService *sender, int ErrorCode, void *user, int NewRSIPAvailable, int NewNATEnabled)</td></tr>
<tr class="separator:aff9aaea4fe103262a2d9889ad54dcbc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f7658867ecadf04f727fb19ffaa45c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2f7658867ecadf04f727fb19ffaa45c"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_ResponseSink_GetSpecificPortMappingEntry</b>) (struct UPnPService *sender, int ErrorCode, void *user, unsigned short NewInternalPort, char *NewInternalClient, int NewEnabled, char *NewPortMappingDescription, unsigned int NewLeaseDuration)</td></tr>
<tr class="separator:aa2f7658867ecadf04f727fb19ffaa45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4505d5eb580885888bf1e8202c58e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e4505d5eb580885888bf1e8202c58e7"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_ResponseSink_GetStatusInfo</b>) (struct UPnPService *sender, int ErrorCode, void *user, char *NewConnectionStatus, char *NewLastConnectionError, unsigned int NewUptime)</td></tr>
<tr class="separator:a3e4505d5eb580885888bf1e8202c58e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3432ca446cd26ad6c40cb79026481f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d3432ca446cd26ad6c40cb79026481f"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_ResponseSink_RequestConnection</b>) (struct UPnPService *sender, int ErrorCode, void *user)</td></tr>
<tr class="separator:a9d3432ca446cd26ad6c40cb79026481f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace660d5b2761eedc23b7a21856a4141c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace660d5b2761eedc23b7a21856a4141c"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_ResponseSink_SetConnectionType</b>) (struct UPnPService *sender, int ErrorCode, void *user)</td></tr>
<tr class="separator:ace660d5b2761eedc23b7a21856a4141c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6826e2366e9418074721022ce68bcca9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6826e2366e9418074721022ce68bcca9"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_EventCallback_PortMappingNumberOfEntries</b>) (struct UPnPService *Service, unsigned short value)</td></tr>
<tr class="separator:a6826e2366e9418074721022ce68bcca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95dbe85bdf89090ff977fb16efa8e264"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95dbe85bdf89090ff977fb16efa8e264"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_EventCallback_ExternalIPAddress</b>) (struct UPnPService *Service, char *value)</td></tr>
<tr class="separator:a95dbe85bdf89090ff977fb16efa8e264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288d035d05c9761af15be99a159d5b53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a288d035d05c9761af15be99a159d5b53"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_EventCallback_ConnectionStatus</b>) (struct UPnPService *Service, char *value)</td></tr>
<tr class="separator:a288d035d05c9761af15be99a159d5b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543e68ec1684b554dcc0fc4e27ad168b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a543e68ec1684b554dcc0fc4e27ad168b"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_EventCallback_PossibleConnectionTypes</b>) (struct UPnPService *Service, char *value)</td></tr>
<tr class="separator:a543e68ec1684b554dcc0fc4e27ad168b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af270393fe9806cf890e6a611fae23965"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af270393fe9806cf890e6a611fae23965"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_EventCallback_DiscoverSink</b>) (struct UPnPDevice *Service)</td></tr>
<tr class="separator:af270393fe9806cf890e6a611fae23965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac631f00bf641dc10e1395b48c398003"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac631f00bf641dc10e1395b48c398003"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_EventCallback_RemoveSink</b>) (struct UPnPDevice *Service)</td></tr>
<tr class="separator:aac631f00bf641dc10e1395b48c398003"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5614dd860d3507b1f29d13d9ff22ca8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_g_d___client_8h.html#a5614dd860d3507b1f29d13d9ff22ca8e">IGD_CreateClient</a> (void)</td></tr>
<tr class="separator:a5614dd860d3507b1f29d13d9ff22ca8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a82880dc624cd496e754e01fade2d82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_g_d___client_8h.html#a6a82880dc624cd496e754e01fade2d82">IGD_DestroyClient</a> (<a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a> hIGD)</td></tr>
<tr class="separator:a6a82880dc624cd496e754e01fade2d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aaf99186122db1b0a06b0eec64aad30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_g_d___client_8h.html#a7aaf99186122db1b0a06b0eec64aad30">IGD_SetDiscoveryCallback</a> (IGD_EventCallback_DiscoverSink cbDiscoverSink, IGD_EventCallback_RemoveSink cbRemoveSink)</td></tr>
<tr class="separator:a7aaf99186122db1b0a06b0eec64aad30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b056dd27c6ddb0f8647ba4c1aa058a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_g_d___client_8h.html#a37b056dd27c6ddb0f8647ba4c1aa058a">IGD_SetEventCallback</a> (IGD_EventCallback_PortMappingNumberOfEntries cbPortMappingNumberOfEntries, IGD_EventCallback_ExternalIPAddress cbExternalIPAddress, IGD_EventCallback_ConnectionStatus cbConnectionStatus, IGD_EventCallback_PossibleConnectionTypes cbPossibleConnectionTypes)</td></tr>
<tr class="separator:a37b056dd27c6ddb0f8647ba4c1aa058a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14bebc4a58374dfc355fe938d1db90e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_g_d___client_8h.html#ae14bebc4a58374dfc355fe938d1db90e">IGD_SelectDevice</a> (<a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a> hIGD, const char *udn)</td></tr>
<tr class="separator:ae14bebc4a58374dfc355fe938d1db90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f6af7b98c55f7cdefa50cd4aed5920"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_g_d___client_8h.html#a12f6af7b98c55f7cdefa50cd4aed5920">IGD_AddPortMapping</a> (<a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a> hIGD, IGD_ResponseSink_AddPortMapping CallbackPtr, void *_user, char *unescaped_NewRemoteHost, unsigned short NewExternalPort, char *unescaped_NewProtocol, unsigned short NewInternalPort, char *unescaped_NewInternalClient, int NewEnabled, char *unescaped_NewPortMappingDescription, unsigned int NewLeaseDuration)</td></tr>
<tr class="separator:a12f6af7b98c55f7cdefa50cd4aed5920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749bdd087e88863dc88f5ac378191755"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_g_d___client_8h.html#a749bdd087e88863dc88f5ac378191755">IGD_DeletePortMapping</a> (<a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a> hIGD, IGD_ResponseSink_DeletePortMapping CallbackPtr, void *_user, char *unescaped_NewRemoteHost, unsigned short NewExternalPort, char *unescaped_NewProtocol)</td></tr>
<tr class="separator:a749bdd087e88863dc88f5ac378191755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009ce97b685e87755166ff00a8384daa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_g_d___client_8h.html#a009ce97b685e87755166ff00a8384daa">IGD_ForceTermination</a> (<a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a> hIGD, IGD_ResponseSink_ForceTermination CallbackPtr, void *_user)</td></tr>
<tr class="separator:a009ce97b685e87755166ff00a8384daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d61678fdd0e3825a6e1487b27dff20"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_g_d___client_8h.html#af7d61678fdd0e3825a6e1487b27dff20">IGD_GetConnectionTypeInfo</a> (<a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a> hIGD, IGD_ResponseSink_GetConnectionTypeInfo CallbackPtr, void *_user)</td></tr>
<tr class="separator:af7d61678fdd0e3825a6e1487b27dff20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1e95f6418d9da3e788d55e93754d78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_g_d___client_8h.html#acc1e95f6418d9da3e788d55e93754d78">IGD_GetExternalIPAddress</a> (<a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a> hIGD, IGD_ResponseSink_GetExternalIPAddress CallbackPtr, void *_user)</td></tr>
<tr class="separator:acc1e95f6418d9da3e788d55e93754d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74214d79114eaf144e9720884a44aec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_g_d___client_8h.html#ad74214d79114eaf144e9720884a44aec">IGD_GetGenericPortMappingEntry</a> (<a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a> hIGD, IGD_ResponseSink_GetGenericPortMappingEntry CallbackPtr, void *_user, unsigned short NewPortMappingIndex)</td></tr>
<tr class="separator:ad74214d79114eaf144e9720884a44aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa180ada75c67170c265959e4b2c0236a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_g_d___client_8h.html#aa180ada75c67170c265959e4b2c0236a">IGD_GetNATRSIPStatus</a> (<a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a> hIGD, IGD_ResponseSink_GetNATRSIPStatus CallbackPtr, void *_user)</td></tr>
<tr class="separator:aa180ada75c67170c265959e4b2c0236a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1402efd61290d7481aca2800d6927d89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_g_d___client_8h.html#a1402efd61290d7481aca2800d6927d89">IGD_GetSpecificPortMappingEntry</a> (<a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a> hIGD, IGD_ResponseSink_GetSpecificPortMappingEntry CallbackPtr, void *_user, char *unescaped_NewRemoteHost, unsigned short NewExternalPort, char *unescaped_NewProtocol)</td></tr>
<tr class="separator:a1402efd61290d7481aca2800d6927d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7c73f7cba12b8162efd3f7190f7e5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_g_d___client_8h.html#aaa7c73f7cba12b8162efd3f7190f7e5e">IGD_GetStatusInfo</a> (<a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a> hIGD, IGD_ResponseSink_GetStatusInfo CallbackPtr, void *_user)</td></tr>
<tr class="separator:aaa7c73f7cba12b8162efd3f7190f7e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3b4a75eec0ec62b6cbb228ee37b39c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_g_d___client_8h.html#a7d3b4a75eec0ec62b6cbb228ee37b39c">IGD_RequestConnection</a> (<a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a> hIGD, IGD_ResponseSink_RequestConnection CallbackPtr, void *_user)</td></tr>
<tr class="separator:a7d3b4a75eec0ec62b6cbb228ee37b39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457c557917356272245628aff81c3d3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_g_d___client_8h.html#a457c557917356272245628aff81c3d3b">IGD_SetConnectionType</a> (<a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a> hIGD, IGD_ResponseSink_SetConnectionType CallbackPtr, void *_user, char *unescaped_NewConnectionType)</td></tr>
<tr class="separator:a457c557917356272245628aff81c3d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a32e63a1ccc40805a9aff21243d52bef7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32e63a1ccc40805a9aff21243d52bef7"></a>
IGD_EventCallback_DiscoverSink&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_EventCallback_WANIPConnectionDevice_DiscoverSink</b></td></tr>
<tr class="separator:a32e63a1ccc40805a9aff21243d52bef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03a8e580899859dbe4275661325348f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa03a8e580899859dbe4275661325348f"></a>
IGD_EventCallback_RemoveSink&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_EventCallback_WANIPConnectionDevice_RemoveSink</b></td></tr>
<tr class="separator:aa03a8e580899859dbe4275661325348f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76960bc7e24df416dfbf3dc656a6c6e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae76960bc7e24df416dfbf3dc656a6c6e"></a>
IGD_EventCallback_PortMappingNumberOfEntries&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_EventCallback_WANIPConnection_PortMappingNumberOfEntries</b></td></tr>
<tr class="separator:ae76960bc7e24df416dfbf3dc656a6c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0420d6eabd39d24a41af744cada88769"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0420d6eabd39d24a41af744cada88769"></a>
IGD_EventCallback_ExternalIPAddress&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_EventCallback_WANIPConnection_ExternalIPAddress</b></td></tr>
<tr class="separator:a0420d6eabd39d24a41af744cada88769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17c8c261fd237ed676d8a32b07bf3ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad17c8c261fd237ed676d8a32b07bf3ed"></a>
IGD_EventCallback_ConnectionStatus&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_EventCallback_WANIPConnection_ConnectionStatus</b></td></tr>
<tr class="separator:ad17c8c261fd237ed676d8a32b07bf3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076778a7353317f735dcfc5b5f7bfa2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a076778a7353317f735dcfc5b5f7bfa2e"></a>
IGD_EventCallback_PossibleConnectionTypes&#160;</td><td class="memItemRight" valign="bottom"><b>IGD_EventCallback_WANIPConnection_PossibleConnectionTypes</b></td></tr>
<tr class="separator:a076778a7353317f735dcfc5b5f7bfa2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a12f6af7b98c55f7cdefa50cd4aed5920"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IGD_AddPortMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hIGD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IGD_ResponseSink_AddPortMapping&#160;</td>
          <td class="paramname"><em>CallbackPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>unescaped_NewRemoteHost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>NewExternalPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>unescaped_NewProtocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>NewInternalPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>unescaped_NewInternalClient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NewEnabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>unescaped_NewPortMappingDescription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>NewLeaseDuration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This action creates a new port mapping or overwrites an existing mapping with the same internal client.<br />
If the ExternalPort and PortMappingProtocol pair is already mapped to another internal client, an error is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hIGD</td><td>handle of IGD control point </td></tr>
    <tr><td class="paramname">CallbackPtr</td><td>Reseponse callback of AddPortMapping. </td></tr>
    <tr><td class="paramname">_user</td><td>This value passes through CallbackPtr. </td></tr>
    <tr><td class="paramname">unescaped_NewRemoteHost</td><td>This variable represents the source of inbound IP packets. This will be a wildcard in most cases (i.e. an empty string). NAT vendors are only required to support wildcards. A non-wildcard value will allow for “narrow” port mappings, which may be desirable in some usage scenarios.When RemoteHost is a wildcard, all traffic sent to the ExternalPort on the WAN interface of the gateway is forwarded to the InternalClient on the InternalPort. When RemoteHost is specified as one external IP address as opposed to a wildcard, the NAT will only forward inbound packets from this RemoteHost to the InternalClient, all other packets will be dropped. </td></tr>
    <tr><td class="paramname">NewExternalPort</td><td>This variable represents the external port that the NAT gateway would “listen” on for connection<br />
requests to a corresponding InternalPort on an InternalClient.. Inbound packets to this<br />
external port on the WAN interface of the gateway should be forwarded to InternalClient on<br />
the InternalPort on which the message was received. If this value is specified as a wildcard<br />
(i.e. 0), connection request on all external ports (that are not otherwise mapped) will be forwarded to InternalClient. In the wildcard case, the value(s) of InternalPort on InternalClient are ignored by the IGD for those connections that are forwarded to InternalClient. Obviously only one such entry can exist in the NAT at any time and conflicts are handled with a “first write wins” behavior. </td></tr>
    <tr><td class="paramname">unescaped_NewProtocol</td><td>This variable represents the protocol of the port mapping. Possible values are TCP or UDP. </td></tr>
    <tr><td class="paramname">NewInternalPort</td><td>This variable represents the port on InternalClient that the gateway should forward connection requests to. A value of 0 is not allowed. NAT implementations that do not permit different values for ExternalPort and InternalPort will return an error. </td></tr>
    <tr><td class="paramname">unescaped_NewInternalClient</td><td>This variable represents the IP address or DNS host name of an internal client (on the residential LAN). Note that if the gateway does not support DHCP, it does not have to support DNS host names. Consequently, support for an IP address is mandatory and support for DNS host names is recommended. This value cannot be a wildcard (i.e. empty string). It must be possible to set the InternalClient to the broadcast IP address 255.255.255.255 for UDP mappings. This is to enable multiple NAT clients to use the same well-known port simultaneously. </td></tr>
    <tr><td class="paramname">NewEnabled</td><td>This variable allows security conscious users to disable and enable dynamic and static NAT port mappings on the IGD. </td></tr>
    <tr><td class="paramname">unescaped_NewPortMappingDescription</td><td>This is a string representation of a port mapping and is applicable for static and dynamic port mappings. The format of the description string is not specified and is application dependent. If specified, the description string can be displayed to a user via the UI of a control point, enabling easier management of port mappings. The description string for a port mapping (or a set of related port mappings) may or may not be unique across multiple instantiations of an application on multiple nodes in the residential LAN. </td></tr>
    <tr><td class="paramname">NewLeaseDuration</td><td>This variable determines the time to live in seconds of a port-mapping lease. A value of 0 means the port mapping is static. Non-zero values will allow support for dynamic port mappings. Note that static port mappings do not necessarily mean persistence of these mappings across device resets or reboots. It is up to a gateway vendor to implement persistence as appropriate for their IGD device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="a5614dd860d3507b1f29d13d9ff22ca8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a> IGD_CreateClient </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create IGD control point </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N/A</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle of IGD Control Point </dd></dl>

</div>
</div>
<a class="anchor" id="a749bdd087e88863dc88f5ac378191755"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IGD_DeletePortMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hIGD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IGD_ResponseSink_DeletePortMapping&#160;</td>
          <td class="paramname"><em>CallbackPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>unescaped_NewRemoteHost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>NewExternalPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>unescaped_NewProtocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This action deletes a previously instantiated port mapping. As each entry is deleted, the array is compacted, and the evented variable PortMappingNumberOfEntries is decremented. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hIGD</td><td>handle of IGD control point </td></tr>
    <tr><td class="paramname">CallbackPtr</td><td>Reseponse callback of DeletePortMapping. </td></tr>
    <tr><td class="paramname">_user</td><td>This value passes through CallbackPtr. </td></tr>
    <tr><td class="paramname">unescaped_NewRemoteHost</td><td>This variable represents the source of inbound IP packets. This will be a wildcard in most cases (i.e. an empty string). NAT vendors are only required to support wildcards. A non-wildcard value will allow for “narrow” port mappings, which may be desirable in some usage scenarios.When RemoteHost is a wildcard, all traffic sent to the ExternalPort on the WAN interface of the gateway is forwarded to the InternalClient on the InternalPort. When RemoteHost is specified as one external IP address as opposed to a wildcard, the NAT will only forward inbound packets from this RemoteHost to the InternalClient, all other packets will be dropped. </td></tr>
    <tr><td class="paramname">NewExternalPort</td><td>This variable represents the external port that the NAT gateway would “listen” on for connection<br />
requests to a corresponding InternalPort on an InternalClient.. Inbound packets to this<br />
external port on the WAN interface of the gateway should be forwarded to InternalClient on<br />
the InternalPort on which the message was received. If this value is specified as a wildcard<br />
(i.e. 0), connection request on all external ports (that are not otherwise mapped) will be forwarded to InternalClient. In the wildcard case, the value(s) of InternalPort on InternalClient are ignored by the IGD for those connections that are forwarded to InternalClient. Obviously only one such entry can exist in the NAT at any time and conflicts are handled with a “first write wins” behavior. </td></tr>
    <tr><td class="paramname">unescaped_NewProtocol</td><td>This variable represents the protocol of the port mapping. Possible values are TCP or UDP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="a6a82880dc624cd496e754e01fade2d82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IGD_DestroyClient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hIGD</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy IGD control point </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hIGD</td><td>handle of IGD Control Point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="a009ce97b685e87755166ff00a8384daa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IGD_ForceTermination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hIGD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IGD_ResponseSink_ForceTermination&#160;</td>
          <td class="paramname"><em>CallbackPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A client may send this command to any connection instance in Connected,Connecting, PendingDisconnect or Disconnecting state to change ConnectionStatus to Disconnected. Connection state immediately transitions to Disconnected irrespective of the setting of WarnDisconnectDelay variable. The process of terminating a connection is described in Theory of Operation section. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hIGD</td><td>handle of IGD control point </td></tr>
    <tr><td class="paramname">CallbackPtr</td><td>Reseponse callback of ForceTermination. </td></tr>
    <tr><td class="paramname">_user</td><td>This value passes through CallbackPtr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="af7d61678fdd0e3825a6e1487b27dff20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IGD_GetConnectionTypeInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hIGD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IGD_ResponseSink_GetConnectionTypeInfo&#160;</td>
          <td class="paramname"><em>CallbackPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This action retrieves the values of the current connection type and allowable connection types. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hIGD</td><td>handle of IGD control point </td></tr>
    <tr><td class="paramname">CallbackPtr</td><td>Reseponse callback of ConnectionTypeInfo. </td></tr>
    <tr><td class="paramname">_user</td><td>This value passes through CallbackPtr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="acc1e95f6418d9da3e788d55e93754d78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IGD_GetExternalIPAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hIGD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IGD_ResponseSink_GetExternalIPAddress&#160;</td>
          <td class="paramname"><em>CallbackPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This action retrieves the value of the external IP address on this connection instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hIGD</td><td>handle of IGD control point </td></tr>
    <tr><td class="paramname">CallbackPtr</td><td>Reseponse callback of GetExternalIPAddress. </td></tr>
    <tr><td class="paramname">_user</td><td>This value passes through CallbackPtr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="ad74214d79114eaf144e9720884a44aec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IGD_GetGenericPortMappingEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hIGD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IGD_ResponseSink_GetGenericPortMappingEntry&#160;</td>
          <td class="paramname"><em>CallbackPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>NewPortMappingIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This action retrieves NAT port mappings one entry at a time. Control points can call this action with an incrementing array index until no more entries are found on the gateway. If PortMappingNumberOfEntries is updated during a call, the process may have to start over. Entries in the array are contiguous. As entries are deleted, the array is compacted, and the evented variable PortMappingNumberOfEntries is decremented. Port mappings are logically stored as an array on the IGD and retrieved using an array index ranging from 0 to PortMappingNumberOfEntries-1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hIGD</td><td>handle of IGD control point </td></tr>
    <tr><td class="paramname">CallbackPtr</td><td>Reseponse callback of GetGenericPortMappingEntry. </td></tr>
    <tr><td class="paramname">_user</td><td>This value passes through CallbackPtr. </td></tr>
    <tr><td class="paramname">NewPortMappingIndex</td><td>Zero based index of Port Mapping.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="aa180ada75c67170c265959e4b2c0236a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IGD_GetNATRSIPStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hIGD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IGD_ResponseSink_GetNATRSIPStatus&#160;</td>
          <td class="paramname"><em>CallbackPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This action retrieves the current state of NAT and RSIP on the gateway for this connection. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hIGD</td><td>handle of IGD control point </td></tr>
    <tr><td class="paramname">CallbackPtr</td><td>Reseponse callback of GetNATRSIPStatus. </td></tr>
    <tr><td class="paramname">_user</td><td>This value passes through CallbackPtr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="a1402efd61290d7481aca2800d6927d89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IGD_GetSpecificPortMappingEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hIGD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IGD_ResponseSink_GetSpecificPortMappingEntry&#160;</td>
          <td class="paramname"><em>CallbackPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>unescaped_NewRemoteHost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>NewExternalPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>unescaped_NewProtocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This action reports the Static Port Mapping specified by the unique tuple of RemoteHost, ExternalPort and PortMappingProtocol. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hIGD</td><td>handle of IGD control point </td></tr>
    <tr><td class="paramname">CallbackPtr</td><td>Reseponse callback of GetSpecificPortMappingEntry. </td></tr>
    <tr><td class="paramname">_user</td><td>This value passes through CallbackPtr. </td></tr>
    <tr><td class="paramname">unescaped_NewRemoteHost</td><td>This variable represents the source of inbound IP packets. This will be a wildcard in most cases (i.e. an empty string). NAT vendors are only required to support wildcards. A non-wildcard value will allow for “narrow” port mappings, which may be desirable in some usage scenarios.When RemoteHost is a wildcard, all traffic sent to the ExternalPort on the WAN interface of the gateway is forwarded to the InternalClient on the InternalPort. When RemoteHost is specified as one external IP address as opposed to a wildcard, the NAT will only forward inbound packets from this RemoteHost to the InternalClient, all other packets will be dropped. </td></tr>
    <tr><td class="paramname">NewExternalPort</td><td>This variable represents the external port that the NAT gateway would “listen” on for connection<br />
requests to a corresponding InternalPort on an InternalClient.. Inbound packets to this<br />
external port on the WAN interface of the gateway should be forwarded to InternalClient on<br />
the InternalPort on which the message was received. If this value is specified as a wildcard<br />
(i.e. 0), connection request on all external ports (that are not otherwise mapped) will be forwarded to InternalClient. In the wildcard case, the value(s) of InternalPort on InternalClient are ignored by the IGD for those connections that are forwarded to InternalClient. Obviously only one such entry can exist in the NAT at any time and conflicts are handled with a “first write wins” behavior. </td></tr>
    <tr><td class="paramname">unescaped_NewProtocol</td><td>This variable represents the protocol of the port mapping. Possible values are TCP or UDP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="aaa7c73f7cba12b8162efd3f7190f7e5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IGD_GetStatusInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hIGD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IGD_ResponseSink_GetStatusInfo&#160;</td>
          <td class="paramname"><em>CallbackPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This action retrieves the values of state variables pertaining to connection status. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hIGD</td><td>handle of IGD control point </td></tr>
    <tr><td class="paramname">CallbackPtr</td><td>Reseponse callback of GetStatusInfo. </td></tr>
    <tr><td class="paramname">_user</td><td>This value passes through CallbackPtr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="a7d3b4a75eec0ec62b6cbb228ee37b39c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IGD_RequestConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hIGD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IGD_ResponseSink_RequestConnection&#160;</td>
          <td class="paramname"><em>CallbackPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A client sends this action to initiate a connection on an instance of a connection service that has a configuration already defined. RequestConnection causes the ConnectionStatus to immediately change to Connecting (if implemented) unless the action is not permitted in the current state of the IGD or the specific service instance. This change of state will be evented. RequestConnection should synchronously return at this time in accordance with UPnP architecture requirements that mandate that an action can take no more than 30 seconds to respond synchronously. However, the actual connection setup may take several seconds more to complete. If the connection setup is successful, ConnectionStatus will change to Connected and will be evented. If the connection setup is not successful, ConnectionStatus will eventually revert back to Disconnected and will be evented. LastConnectionError will be set appropriately in either case. While this may be obvious, it is worth noting that a control point must not source packets to the Internet until ConnectionStatus is updated to Connected, or the IGD may drop packets until it transitions to the Connected state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hIGD</td><td>handle of IGD control point </td></tr>
    <tr><td class="paramname">CallbackPtr</td><td>Reseponse callback of RequestConnection. </td></tr>
    <tr><td class="paramname">_user</td><td>This value passes through CallbackPtr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="ae14bebc4a58374dfc355fe938d1db90e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IGD_SelectDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hIGD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>udn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>IGD Device has its unique id(uuid). this uuid is called as UDN. After discovering IGD Device, Its control point must select the IGD deivce with its UDN in order to invoke the APIs of IGD. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hIGD</td><td>handle of IGD control point </td></tr>
    <tr><td class="paramname">udn</td><td>UDN of IGD</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="a457c557917356272245628aff81c3d3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IGD_SetConnectionType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structigd__handle__tag.html">IGD_HANDLE</a>&#160;</td>
          <td class="paramname"><em>hIGD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IGD_ResponseSink_SetConnectionType&#160;</td>
          <td class="paramname"><em>CallbackPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>unescaped_NewConnectionType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This action sets up a specific connection type. Clients on the LAN may initiate or share connection only after this action completes or ConnectionType is set to a value other than Unconfigured. ConnectionType can be a read-only variable in cases where some form of auto configuration is employed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hIGD</td><td>handle of IGD control point </td></tr>
    <tr><td class="paramname">CallbackPtr</td><td>Reseponse callback of SetConnectionType. </td></tr>
    <tr><td class="paramname">_user</td><td>This value passes through CallbackPtr. </td></tr>
    <tr><td class="paramname">unescaped_NewConnectionType</td><td>This variable is set to specify the connection type(IP_Routed or IP_Bridged) for a specific active connection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="a7aaf99186122db1b0a06b0eec64aad30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IGD_SetDiscoveryCallback </td>
          <td>(</td>
          <td class="paramtype">IGD_EventCallback_DiscoverSink&#160;</td>
          <td class="paramname"><em>cbDiscoverSink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IGD_EventCallback_RemoveSink&#160;</td>
          <td class="paramname"><em>cbRemoveSink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register callback functions which is called when IGD is discovered or disappeared. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hIGD</td><td>handle of IGD Control Point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N/A </dd></dl>

</div>
</div>
<a class="anchor" id="a37b056dd27c6ddb0f8647ba4c1aa058a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IGD_SetEventCallback </td>
          <td>(</td>
          <td class="paramtype">IGD_EventCallback_PortMappingNumberOfEntries&#160;</td>
          <td class="paramname"><em>cbPortMappingNumberOfEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IGD_EventCallback_ExternalIPAddress&#160;</td>
          <td class="paramname"><em>cbExternalIPAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IGD_EventCallback_ConnectionStatus&#160;</td>
          <td class="paramname"><em>cbConnectionStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IGD_EventCallback_PossibleConnectionTypes&#160;</td>
          <td class="paramname"><em>cbPossibleConnectionTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If IGD device's state is changed, IGD device notifies its event to IGD control point. When IGD control point receives the event, event callback fucntion is called at that time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hIGD</td><td>handle of IGD Control Point </td></tr>
    <tr><td class="paramname">cbPortMappingNumberOfEntries</td><td></td></tr>
    <tr><td class="paramname">cbExternalIPAddress</td><td></td></tr>
    <tr><td class="paramname">cbConnectionStatus</td><td></td></tr>
    <tr><td class="paramname">cbPossibleConnectionTypes</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N/A </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
